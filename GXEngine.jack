// Graphics Engine
// Destorys all drawable objects when destroyed.

class GXEngine {

  field Settings settings;
  field ObjectManager OM;
  field Array playerSpriteList;
  field AdvancedMath mathEngine;

  field int resX, resY, screenSizeX, screenSizeY;
  field int screenLeftX, screenRightX;
  field int screenTopY, screenBottomY;


  constructor GXEngine new(Settings gameSettings, ObjectManager newOM) {
    var int i;

    let settings=gameSettings;
    let mathEngine=AdvancedMath.new();
    let OM = newOM;
    let playerSpriteList = Array.new(settings.getMaxPlayers());
    let resX = settings.getworldResolutionX();
    let resY = settings.getworldResolutionY();
    let screenSizeX = settings.getscreenSizeX();
    let screenSizeY = settings.getscreenSizeY();

    let screenLeftX = settings.getScreenBoundLeft();
    let screenRightX = settings.getScreenBoundRight();
    let screenTopY=settings.getScreenBoundTop();
    let screenBottomY=settings.getScreenBoundBottom();

    // initialize playerSpriteList
    let i=0;
    while (i<settings.getMaxPlayers()) {
      let playerSpriteList[i] = 0;
      let i=i+1; }

    return this;
  }

  method void registerPlayerSprite(PlayerSprite newPlayerSprite) {
    // adds a player sprite to the list

    var int i;
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let i=i+1;
    }
    let playerSpriteList[i] = newPlayerSprite;

    return;
  }

  method void drawAllObjects(bool forceDraw) {
    // draws everything in its object lists that needs updating.
    // if forceDraw=true, it'll draw everything regardless.
    var int i;
    var Attributes fooatt;
    var Bullet fooBull;
    var PlayerSprite fooPS;
    var GravitySink fooGS;

    // draw gravitySinks
    let i = 0;
    while(~(OM.getGravitySink(i) = 0)) {
      let fooGS=OM.getGravitySink(i);
      let fooatt = fooGS.getAttributes();
      if (fooatt.getNeedsUpdate() | forceDraw){ // redraw sprite if it needs to be redrawn.
        do drawGravitySink(fooGS, false); // erase
        do drawGravitySink(fooGS, true); // then draw
        do fooatt.setNeedsUpdate(false);
      }
      let i=i+1;
    }
    // draw bullets
    let i = 0;
    while(~(OM.getBullet(i) = 0) ) {
      let fooatt = OM.getBulletAttributes(i);
      do drawBullet(OM.getBullet(i), false);
      do drawBullet(OM.getBullet(i), true);
      do fooatt.setNeedsUpdate(false);

      let i=i+1;
    }
    // draw playerSprites
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let fooPS=playerSpriteList[i];
      let fooatt = fooPS.getAttributes();
      if (fooatt.getNeedsUpdate() | forceDraw){ // redraw sprite if it needs to be redrawn.
        do drawPlayerSprite(fooPS, false); // erase
        do drawPlayerSprite(fooPS, true); // then draw
        do fooatt.setNeedsUpdate(false);
      }
      let i=i+1;
    }

    return;
  }

  method void drawPlayerSprite(PlayerSprite gs, bool drawOrErase) {
    // draws a single PlayerSprite
    var int x,y,rot;
    var int angle, length;
    var int x1,y1, x2,y2, x3,y3; // 1-front, 2-back left, 3-back right
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    let angle = settings.getPlayerSpritePointAngle();
    let length = settings.getPlayerSpriteSideLength();

    if (drawOrErase) {
      let x = currentAttributes.getPx()/resX + settings.getScreenBoundLeft(); // we're dividing by resolution to
      let y = currentAttributes.getPy()/resY + settings.getScreenBoundTop(); // convert from real space to pixel space
      let rot = currentAttributes.getRotation();
    } else {
      // if we're erasing we need to use the old attributes
      let x = currentAttributes.getOldPx()/resX + settings.getScreenBoundLeft();
      let y = currentAttributes.getOldPy()/resY + settings.getScreenBoundTop();
      let rot = currentAttributes.getOldRotation();
    }

    let x1=x;
    let y1=y;

    let x1=x+((mathEngine.sin100(rot)*(length/2))/100);
    let y1=y-((mathEngine.cos100(rot)*(length/2))/100);

    let x2=x1-((mathEngine.sin100(rot-angle)*length)/100);
    let y2=y1+((mathEngine.cos100(rot-angle)*length)/100);

    let x3=x1-((mathEngine.sin100(rot+angle)*length)/100);
    let y3=y1+((mathEngine.cos100(rot+angle)*length)/100);

    do Screen.setColor(drawOrErase);
    do Screen.drawLine(x1, y1, x2, y2);
    do Screen.drawLine(x2, y2, x3, y3);
    do Screen.drawLine(x3, y3, x1, y1);
   return;
  }

  method void drawGravitySink(GravitySink gs, bool drawOrErase) {
    // draws a single gravitySink
    var int x,y,r;
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    let x = currentAttributes.getPx()/resX + settings.getScreenBoundLeft(); // convert from real space to
    let y = currentAttributes.getPy()/resY + settings.getScreenBoundTop(); // pixel space
    let r = currentAttributes.getRadius();

    do Screen.setColor(drawOrErase);
    do Screen.drawCircle(x, y, r);
   return;
  }


  method void drawBullet(Bullet gs, bool drawOrErase) {
    // draws a single bullet
    var int x,y,r;
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    if (drawOrErase) {
      let x = currentAttributes.getPx()/resX + settings.getScreenBoundLeft(); // we're dividing by resolution to
      let y = currentAttributes.getPy()/resY + settings.getScreenBoundTop(); // convert from real space to pixel space
      let r = currentAttributes.getRadius();
    } else {
      // if we're erasing we need to use the old attributes
      let x = currentAttributes.getOldPx()/resX + settings.getScreenBoundLeft();
      let y = currentAttributes.getOldPy()/resY + settings.getScreenBoundTop();
      let r = currentAttributes.getOldRadius();
    }



    do Screen.setColor(drawOrErase);
    do Screen.drawCircle(x, y, r);
   return;
  }

  method void drawScreenEdges() {
    do Screen.setColor(true);
    do Screen.drawLine(screenLeftX, screenTopY, screenRightX, screenTopY);
    do Screen.drawLine(screenRightX, screenTopY, screenRightX, screenBottomY);
    do Screen.drawLine(screenRightX, screenBottomY, screenLeftX, screenBottomY);
    do Screen.drawLine(screenLeftX, screenBottomY, screenLeftX, screenTopY);
    return;
  }

  method void drawPowerIndicator(int maxPower, int powerRemaining,int powerSetting) {
    var int x,y,height, width, carrotWidth, carrotHalfHight;
    var int powerIndicatorRatio; // ratio between the power indicator height
                             // and the max amount of power
    let x=1;
    let y=20;
    let height=100;
    let width=10;
    let carrotWidth=3;
    let carrotHalfHight = 3;


    let powerIndicatorRatio = maxPower/height;

    // erase previous power indicator
    do Screen.setColor(false);
    do Screen.drawRectangle(x,y, x+width+carrotWidth,y+height);

    do Screen.setColor(true);
    // draw power remaining indicator
    do Screen.drawRectangle(x+2,y+((maxPower - powerRemaining)/powerIndicatorRatio),
                            x+width-4,y+height);

    // draw power setting carrot
    do Screen.drawLine(x+width,  y+height-(powerSetting/powerIndicatorRatio),
                    x+width+carrotWidth, y+height-(powerSetting/powerIndicatorRatio)-carrotHalfHight );
    do Screen.drawLine(x+width,  y+height-(powerSetting/powerIndicatorRatio),
                    x+width+carrotWidth, y+height-(powerSetting/powerIndicatorRatio)+carrotHalfHight );

    return;
  }

  method void drawExplosion(int x, int y, int size) {
    // Draws a cool exposion to the screen
    do Screen.setColor(true);
    do Screen.drawCircle(x+(size/2),y,size/2);
    do Screen.drawCircle(x,y+(size/2),size/2);
    do Screen.setColor(false);
    do Screen.drawCircle(x+(size/3),y,size/2);
    do Screen.drawCircle(x,y+(size/3),size/2);
    do Screen.setColor(true);
    do Screen.drawCircle(x-(size/2),y,size/2);
    do Screen.drawCircle(x,y+(size/2),size/2);
    do Screen.setColor(false);
    do Screen.drawCircle(x+(size/3),y,size/2);
    do Screen.drawCircle(x,y-(size/3),size/2);
    do Sys.wait(100);
    do Screen.setColor(false);
    do Screen.drawCircle(x-(size/3),y,size/2);
    do Screen.drawCircle(x,y+(size/2),size/2);
    do Screen.setColor(true);
    do Screen.drawCircle(x+(size/3),y,size/2);
    do Screen.drawCircle(x,y-(size/2),size/2);
    do Screen.setColor(false);
    do Screen.drawCircle(x+(size/3),y,size/2);
    do Screen.drawCircle(x,y+(size/2),size/2);
    do Screen.setColor(true);
    do Screen.drawCircle(x+(size/3),y,size/2);
    do Screen.drawCircle(x,y-(size/4),size/2);
    do Sys.wait(100);
    return;
  }

  method void displayGameResult(int gameResult) {
    // displays the winner of a game.
    // 0-Draw, 1-Player 1 wins 2-Player 2 wins
    do Screen.setColor(true);
    do Screen.drawRectangle(0,110,500,122);
    do Output.moveCursor(10,23);
    do Output.printString(" Player ");
    do Output.printInt(gameResult);
    do Output.printString(" Wins! ");


    return;
  }

  method void doInto() {

    var int titleX, titleY;
    var int menuX, menuY;
    var int currentSelection, finalSelection;
    var int carrotX, carrotY, carrotY0;
    var int carrotHalfHight, carrotWidth;
    var int numberOfSelections;
    var int currentNumberOfPlayers;
    var int distanceBetweenItems;
    var char selectionKey;
    var char upKey, downKey, leftKey, rightKey;
    var char carrot, spaceChar, enterChar;
    var int randomSeed;

    let titleX = 20;
    let titleY = 2;
    let menuX = 10;
    let menuY = 5;
    let distanceBetweenItems=2;
    let numberOfSelections = 3;
    let upKey = 131;
    let downKey = 133;
    let leftKey = 130;
    let rightKey = 132;
    let carrot = 62;
    let spaceChar=32;
    let enterChar = 128;

    let carrotX = 20;
    let finalSelection=0;
    let currentSelection =1;
    let currentNumberOfPlayers=2;

    // print title
    do Output.moveCursor(titleY, titleX);
    do Output.printString("GRAVITY WARS!");


    // print menu
    do Output.moveCursor(menuY,menuX);
    do Output.printString("Engage in a GRAVITY WAR");
    do Output.moveCursor(menuY+distanceBetweenItems,menuX);
    do Output.printString("Number of PLAYERS: ");
    do Output.printInt(currentNumberOfPlayers);
    do Output.moveCursor(menuY+(distanceBetweenItems*2),menuX);
    do Output.printString("Instructions");


    // Print cursor
    do Output.moveCursor(currentSelection-1+menuY,menuX-1);
    do Output.printChar(carrot);

    while (finalSelection=0){
      let selectionKey=Keyboard.keyPressed();

      // Start Keyboard Handling
      if ( ~(selectionKey=0) ) {
        do Output.moveCursor((currentSelection-1)*distanceBetweenItems+menuY,menuX-1);
        do Output.printChar(spaceChar);}

      if ( (selectionKey=upKey) & (currentSelection>1) ){let currentSelection = currentSelection-1; }
      if ( (selectionKey=downKey) & (currentSelection<numberOfSelections) ){let currentSelection = currentSelection+1;}
      if ( (selectionKey=rightKey) & (currentNumberOfPlayers<settings.getMaxPlayers()) & (currentSelection=2) )
        {let currentNumberOfPlayers = currentNumberOfPlayers+1;}
      if ( (selectionKey=leftKey) & (currentNumberOfPlayers>0) & (currentSelection=2) )
        {let currentNumberOfPlayers = currentNumberOfPlayers-1;}
      if ( (selectionKey=spaceChar) | (selectionKey=enterChar) ){let finalSelection = currentSelection;}

      // reprint carrot
      if (~(selectionKey=0)) {
        do Output.moveCursor((currentSelection-1)*distanceBetweenItems+menuY,menuX-1);
        do Output.printChar(carrot);
        do Sys.wait(200);}
      // reprint number of players
      if ( (selectionKey=rightKey) | (selectionKey=leftKey)) {
        do Output.moveCursor(menuY+distanceBetweenItems,menuX+19);
        do Output.printInt(currentNumberOfPlayers);}

      let randomSeed = randomSeed+1;
      do mathEngine.plantSeed(randomSeed);
    }


    return;
  }


  method void dispose() {
    // This will destroy this object as well as all objects
    // registered with it.
    var int i;

    // now suicide
    do Memory.deAlloc(this);
    return;
  }

  method AdvancedMath borrowMathEngine() { return mathEngine;}

}
