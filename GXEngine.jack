// Graphics Engine
// Destorys all drawable objects when destroyed.

class GXEngine {

  field Settings settings;
  field Array gravitySinkList;
  field Array playerSpriteList;
  field Array bulletList;
  field AdvancedMath mathEngine;

  field int resX, resY, screenSizeX, screenSizeY;
  field int screenLeftX, screenRightX;
  field int screenTopY, screenBottomY;


  constructor GXEngine new(Settings gameSettings) {
    var int i;

    let settings=gameSettings;
    let mathEngine=AdvancedMath.new();
    let gravitySinkList = Array.new(settings.getMaxGravitySinks());
    let playerSpriteList = Array.new(settings.getMaxPlayers());
    let bulletList = Array.new(settings.getMaxBullets());
    let resX = settings.getworldResolutionX();
    let resY = settings.getworldResolutionY();
    let screenSizeX = settings.getscreenSizeX();
    let screenSizeY = settings.getscreenSizeY();

    let screenLeftX = 0;
    let screenRightX = screenSizeX;
    let screenTopY=0;
    let screenBottomY=screenSizeY;

    // initialize the gravitySinkList Array with zeros.
    // All lists terminate with a zero.
    let i=0;
    while (i<settings.getMaxGravitySinks()) {
      let gravitySinkList[i] = 0;
      let i=i+1; }
    // initialize playerSpriteList
    let i=0;
    while (i<settings.getMaxPlayers()) {
      let playerSpriteList[i] = 0;
      let i=i+1; }
    // initialize playerSpriteList
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }

    return this;
  }

  method void registerGravitySink(GravitySink newGravitySink) {
    // adds an gravitySink to the list

    var int i;
    let i = 0;
    while(~(gravitySinkList[i]=0) & (i<settings.getMaxGravitySinks()) ) {
      let i=i+1;
    }
    let gravitySinkList[i] = newGravitySink;

    return;
  }

  method void registerPlayerSprite(PlayerSprite newPlayerSprite) {
    // adds a player sprite to the list

    var int i;
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let i=i+1;
    }
    let playerSpriteList[i] = newPlayerSprite;

    return;
  }

  method void registerBullet(Bullet newBullet) {
    // adds a player sprite to the list
    var int i;
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    if (i > (settings.getMaxBullets()-1)) {
      do newBullet.setIsDead(true);
    } else {
    let bulletList[i] = newBullet;
    }

    return;
  }

  method void unregisterBullet(Bullet killBullet) {
    var int i;
    let i = 0;
    while(~(bulletList[i]=killBullet) & ~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    if (bulletList[i]=killBullet) { let bulletList[i]=0;}
    return;
  }

  method void drawAllObjects() {
    // draws everything in its object lists
    var int i;
    var Attributes fooatt;
    var Bullet fooBull;
    var PlayerSprite fooPS;

    // draw gravitySinks
    let i = 0;
    while(~(gravitySinkList[i] = 0) & (i < settings.getMaxGravitySinks()) ) {
      do drawGravitySink(gravitySinkList[i], true);
      let i=i+1;
    }
    // draw bullets
    let i = 0;
    while(~(bulletList[i] = 0) & (i < settings.getMaxBullets()) ) {
      let fooBull = bulletList[i];
      let fooatt = fooBull.getAttributes();
      //do Output.printInt(fooatt.getPx());
      //do Output.printString("  ");
      do drawBullet(bulletList[i], false);
      do drawBullet(bulletList[i], true);
      do fooatt.setNeedsUpdate(false);

      let i=i+1;
    }
    // draw playerSprites
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let fooPS=playerSpriteList[i];
      let fooatt = fooPS.getAttributes();
      if (fooatt.getNeedsUpdate()){ // redraw sprite if it needs to be redrawn.
        do drawPlayerSprite(playerSpriteList[i], false); // erase
        do drawPlayerSprite(playerSpriteList[i], true); // then draw
        do fooatt.setNeedsUpdate(false);
      }
      let i=i+1;
    }

    return;
  }

  method void drawPlayerSprite(PlayerSprite gs, bool drawOrErase) {
    // draws a single PlayerSprite
    var int x,y,rot;
    var int angle, length;
    var int x1,y1, x2,y2, x3,y3; // 1-front, 2-back left, 3-back right
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    let angle = settings.getPlayerSpritePointAngle();
    let length = settings.getPlayerSpriteSideLength();

    if (drawOrErase) {
      let x = currentAttributes.getPx()/resX; // we're dividing by resolution to
      let y = currentAttributes.getPy()/resY; // convert from real space to pixel space
      let rot = currentAttributes.getRotation();
    } else {
      // if we're erasing we need to use the old attributes
      let x = currentAttributes.getOldPx()/resX;
      let y = currentAttributes.getOldPy()/resY;
      let rot = currentAttributes.getOldRotation();
    }

    let x1=x;
    let y1=y;

    let x2=x-((mathEngine.sin100(rot-angle)*length)/100);
    let y2=y+((mathEngine.cos100(rot-angle)*length)/100);

    let x3=x-((mathEngine.sin100(rot+angle)*length)/100);
    let y3=y+((mathEngine.cos100(rot+angle)*length)/100);

    do Screen.setColor(drawOrErase);
    do Screen.drawLine(x1, y1, x2, y2);
    do Screen.drawLine(x2, y2, x3, y3);
    do Screen.drawLine(x3, y3, x1, y1);
   return;
  }

  method void drawGravitySink(GravitySink gs, bool drawOrErase) {
    // draws a single gravitySink
    var int x,y,r;
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    let x = currentAttributes.getPx()/resX; // convert from real space to
    let y = currentAttributes.getPy()/resY; // pixel space
    let r = currentAttributes.getRadius();

    do Screen.setColor(drawOrErase);
    do Screen.drawCircle(x, y, r);
   return;
  }


  method void drawBullet(Bullet gs, bool drawOrErase) {
    // draws a single bullet
    var int x,y,r;
    var Attributes currentAttributes;

    let currentAttributes = gs.getAttributes();
    if (drawOrErase) {
      let x = currentAttributes.getPx()/resX; // we're dividing by resolution to
      let y = currentAttributes.getPy()/resY; // convert from real space to pixel space
      let r = currentAttributes.getRadius();
    } else {
      // if we're erasing we need to use the old attributes
      let x = currentAttributes.getOldPx()/resX;
      let y = currentAttributes.getOldPy()/resY;
      let r = currentAttributes.getOldRadius();
    }



    do Screen.setColor(drawOrErase);
    do Screen.drawCircle(x, y, r);
   return;
  }

  method void drawScreenEdges() {
    do Screen.drawLine(screenLeftX, screenTopY, screenRightX, screenTopY);
    do Screen.drawLine(screenRightX, screenTopY, screenRightX, screenBottomY);
    do Screen.drawLine(screenRightX, screenBottomY, screenLeftX, screenBottomY);
    do Screen.drawLine(screenLeftX, screenBottomY, screenLeftX, screenTopY);
    return;
  }


  method void dispose() {
    // This will destroy this object as well as all objects
    // registered with it.
    var int i;
    var GravitySink gs;

    // destroy gravitySinkList
    let i=0;
    while (i<settings.getMaxGravitySinks()) {
      let gs = gravitySinkList[i];
      do gs.dispose();
      let i=i+1;
    }

    // now suicide
    do Memory.deAlloc(this);
    return;
  }

}
