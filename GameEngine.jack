// Game Engine
// Handles game mechanics

class GameEngine {

  field Settings settings;
  field PXEngine px;
  field GXEngine gx;
  field ObjectManager OM;
  field Array bulletList;
  field Array playerList;
  field int powerSetting;
  field int deBounce; // counts how many frames since the last keystroke
  field Array forceNextRedraw;

  // working variables for methods. Defined here
  // to only make one copy

  constructor GameEngine new(Settings gameSettings,
                             GXEngine myGXEngine,
                             PXEngine myPXEngine,
                             ObjectManager newOM) {

    var int i;

    let settings = gameSettings;
    let OM = newOM;
    let bulletList = Array.new(settings.getMaxBullets());
    // initialize bulletList
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }
    // initialize playerList
    let playerList = Array.new(settings.getMaxPlayers());
    let i=0;
    while (i<settings.getMaxPlayers()) {
      let playerList[i] = 0;
      let i=i+1; }

    let gx = myGXEngine;
    let px = myPXEngine;
    let powerSetting = 20;
    let deBounce = 0;
    // forceNextRedraw Array is a series of flags that
    // indicate what needs to be redrawn at the next refresh.
    // 0 - refreshscreen    1 - all players
    // 2 - power indicator  3 - borders
    let forceNextRedraw=Array.new(3);
    let forceNextRedraw[0]=false; let forceNextRedraw[1]=false; let forceNextRedraw[2]=false;
    return this;
  }


  method void takeTurn(Player player) {
    // Allows a player to take a turn.
    // Returns when either dead or next turn
      var int action;
      var int foo, bar;
      var Attributes currentAttributes;
      var Player fooPlayer;
      var bool stillMyTurn;

      let stillMyTurn=true;
      let currentAttributes = player.getSpriteAttributes();
      let foo = settings.getPlayerStartingPower();
      do player.setPowerRemaining(foo);

      let forceNextRedraw[0]=true;

      while  (stillMyTurn){

        let action = __getInput__();

        if ( (action=1) & (deBounce<1) ) {
          // Jump action
          let foo = currentAttributes.getRotation();
          let bar = settings.getthrusterAcceleration();
          do px.applyAcceleration(currentAttributes,
                               powerSetting*bar, foo);
          let foo=player.getPowerRemaining();
          do player.setPowerRemaining(foo-powerSetting);
          let forceNextRedraw[2]=true;
        }
        if (action=3) {
          let foo=settings.getRotationSensativity()*-1;
          do px.applyRotation(currentAttributes, foo);
        }
        if (action=4) {
          let foo=settings.getRotationSensativity();
          do px.applyRotation(currentAttributes, foo);
        }
        if (action=5) { // increase power
          let foo=settings.getPowerSensativity();
          do changePower(foo, player.getPowerRemaining());
        }
        if (action=6) { // decrease power
          let foo=settings.getPowerSensativity();
          do changePower(foo*-1, player.getPowerRemaining());
        }
        if ( (action=7) & (deBounce<1) ) { //shoot
          do __shoot__(currentAttributes);
          let foo=player.getPowerRemaining();
          do player.setPowerRemaining(foo-powerSetting);
        }
        if (action=8 & (deBounce<1) ) { // quit
          do player.setPowerRemaining(0);
        }

        // if an action occured, make sure the new power setting is not more than
        // the amount of power the player has
        if (~(action=0) & (powerSetting>player.getPowerRemaining())){
          let powerSetting=player.getPowerRemaining();}

        // reset the debounce counter.
        if (~(action=0)) {let deBounce=settings.getDebounceSetting();}
        if (deBounce > 0){ let deBounce = deBounce-1; }

        let foo = settings.getTimeStep();
        do px.stepForward(foo);


        do updateScreen(player);
        do Sys.wait(foo);

        // detect collisions
        do checkForCollisions(player);

        // is it the next dude's turn?
        let foo = 0;
        while(~(playerList[foo]=0) & (foo<settings.getMaxPlayers()) ) {
          let fooPlayer = playerList[foo];
          let stillMyTurn =stillMyTurn & (~fooPlayer.getIsDead());
          let foo=foo+1;
        }
        let stillMyTurn = (stillMyTurn & (player.getPowerRemaining()>0) ) | ~(bulletList[0]=0);
      }
      return;
  }

  method void __shoot__(Attributes playerAttributes) {
    // shoots a bullet from player. playerAttributes
    // is the attributes object from the shooting player
    var Bullet newBullet;
    var Attributes currentAttributes;
    var int Px,Py,radius, accel, rotation,mass;
    var int distanceAhead;
    var AdvancedMath mx;

    let radius=settings.getBulletRadius();
    let accel=powerSetting;
    let Px = playerAttributes.getPx();
    let Py = playerAttributes.getPy();
    let mass=settings.getBulletMass();
    let rotation = playerAttributes.getRotation();
    let distanceAhead = radius+playerAttributes.getRadius()+2;

    let mx = gx.borrowMathEngine();
    let Px = Px + (((mx.sin100(rotation)*(distanceAhead))/100)*settings.getworldResolutionX());
    let Py = Py - (((mx.cos100(rotation)*(distanceAhead))/100)*settings.getworldResolutionX());

    let newBullet = Bullet.new(Px,Py,0,0,radius, mass);
    do registerBullet(newBullet);
    do px.registerBullet(newBullet);
    do OM.registerBullet(newBullet);
    if ( newBullet.getIsDead() ) {
      do newBullet.dispose();
    } else {
      let currentAttributes = newBullet.getAttributes();

      do px.applyAcceleration(currentAttributes,accel, rotation);
    }
    let forceNextRedraw[2]=true;
    return;
  }

  method void changePower(int powerDelta, int powerRemaining) {
    let powerSetting = powerSetting + powerDelta;
    if (powerSetting>powerRemaining) { let powerSetting=powerRemaining;}
    if (powerSetting<0) { let powerSetting=0;}
    let forceNextRedraw[2]=true;
    return;
  }


  method int __getInput__() {
    // Polls the keyboard for input and look up
    // the action in the keybinds. Returns an
    // int coresponding with that action.
    var char inputKey;
    var char action;

    let inputKey = Keyboard.keyPressed();
    //do Output.moveCursor(3,0);
    //do Output.printInt(inputKey);
    // don't register inputs if a recent input was made.
    let action = settings.getDesiredAction(inputKey);
    return action;
  }

  method void updateScreen(Player currentPlayer) {
    // if force redraw is true, it'll blank the screen and
    // redraw everything

    var int powerRemaining;
    var int maxPower;

    if (forceNextRedraw[0]) {
      do Screen.clearScreen();
    }
    if (forceNextRedraw[3]|forceNextRedraw[0]) {
      do gx.drawScreenEdges();
    }
    if (forceNextRedraw[2]|forceNextRedraw[0]) {
      let powerRemaining=currentPlayer.getPowerRemaining();
      let maxPower = settings.getPlayerStartingPower();
      do gx.drawPowerIndicator(maxPower,powerRemaining, powerSetting);
    }
    do Output.moveCursor(0,0);
    do Output.printString(currentPlayer.getName());

    do gx.drawAllObjects(forceNextRedraw[1]|forceNextRedraw[0]);
    let forceNextRedraw[0]=false;
    let forceNextRedraw[1]=false;
    let forceNextRedraw[2]=false;
    let forceNextRedraw[3]=false;
    return;
  }

  method void killBullet(Bullet killBullet) {
    do unregisterBullet(killBullet);
    do px.unregisterBullet(killBullet);
    do OM.unregisterBullet(killBullet);
    do killBullet.dispose();
    let forceNextRedraw[0]=true;
    return;
  }

  method void checkForCollisions(Player player) {
    var int i, collisionCode, activationAge;
    var int x,y;
    var Bullet fooBullet;
    var Player fooPlayer;
    var Attributes currentAttributes;

    // check for player collisions
    let currentAttributes = player.getSpriteAttributes();
    let collisionCode = px.detectCollision(currentAttributes);

    if ( ~(collisionCode = 0) ) {
      do player.kill();
      let x=(currentAttributes.getPx()/settings.getworldResolutionX())+settings.getScreenBoundLeft();
      let y=(currentAttributes.getPy()/settings.getworldResolutionY())+settings.getScreenBoundTop();
      do gx.drawExplosion(x,y,10);
    }
    if ( (collisionCode > 3) ) {
      let fooPlayer = playerList[collisionCode-4]; // you hit another player
      do fooPlayer.kill();
    }


    // check bullet collisions
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let fooBullet = bulletList[i];
      let currentAttributes = fooBullet.getAttributes();
      let collisionCode = px.detectCollision(currentAttributes);
      if (~(collisionCode=0)) {
        do killBullet(fooBullet);
        let x=(currentAttributes.getPx()/settings.getworldResolutionX())+settings.getScreenBoundLeft();
        let y=(currentAttributes.getPy()/settings.getworldResolutionY())+settings.getScreenBoundTop();
        do gx.drawExplosion(x,y,10);
      }
      if ( (collisionCode > 3) ) {
        let fooPlayer = playerList[collisionCode-4]; // you hit another player
        do fooPlayer.kill();
      }
      let i=i+1;
    }
    return;
  }


  method void registerBullet(Bullet newBullet) {
    // adds an bullet to the list
    var int i;
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    // if we've reached the max number if bullets, go ahead and kill this one.
    if (i > (settings.getMaxBullets()-1)) {
      do newBullet.setIsDead(true);
    } else {
    let bulletList[i] = newBullet;
    }
    return;
  }

  method void unregisterBullet(Bullet killBullet) {
    var int i;
    let i = 0;
    while(~(bulletList[i]=killBullet) & ~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    if (bulletList[i]=killBullet) { let bulletList[i]=0;}
    return;
  }

  method void registerPlayer(Player newPlayer) {
    // adds an Player to the list
    var int i;
    let i = 0;
    while(~(playerList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let i=i+1;
    }
    let playerList[i] = newPlayer;

    return;
  }

  method void generateUniverse(GameEngine myGame, GXEngine gx, PXEngine px,
                               Settings settings, Array playerArray,
                               int totalGravity, int numberOfPlayers) {
      var int playerLength;
      var int i;
      var bool cleanCreation;
      var Player ps1;
      var GravitySink gs1;
      var PlayerSprite fooSprite;
      var Attributes att;
      var int maxX, maxY;
      var int rand1, rand2, rand3, rand4;
      var AdvancedMath mx;
      let mx=gx.borrowMathEngine();

      let maxX = settings.getscreenSizeX()*settings.getworldResolutionX();
      let maxY = settings.getscreenSizeY()*settings.getworldResolutionY();
      let playerLength = settings.getPlayerSpriteSideLength()+1;

      // create players
      let i=0;
      while (i<numberOfPlayers) {
        let cleanCreation = false;

        while (~(cleanCreation)){
          do Output.printInt(i);
          let rand1 = mx.random(0,maxX);
          let rand2 = mx.random(0,maxX);
          let rand3 = mx.random(0,360);
          let ps1 = Player.new(i,rand1, rand2, rand3, playerLength,0);
          let att=ps1.getSpriteAttributes();

          if (px.detectCollision(att)=0){
            let cleanCreation=true;
          } else {
            do ps1.dispose();
          }

        }
        //do Output.printString("(");
        //do Output.printInt(att.getPx());
        //do Output.printString(",");
        //do Output.printInt(att.getPy());
        //do Output.printString(")");

        do registerPlayer(ps1);
        let fooSprite = ps1.getSprite();
        do px.registerPlayerSprite(fooSprite);
        let playerArray[i] = ps1;
        let i = i+1;
      }




      //let gs1 = GravitySink.new(10000, 3000, 20, 20);
      //let gs2 = GravitySink.new(2000, 10000, 10, 10);
      //let gs3 = GravitySink.new(20000, 20000, 15, 15);
      //let gs4 = GravitySink.new(30000, 15000, 15, 15);
      //let gs5 = GravitySink.new(25000, 4000, 25, 25);
      //let ps1 = Player.new("1",3000, 3000, 180, playerLength,0);
      //let ps2 = Player.new("2",15000, 15000, 60, playerLength,0);

      return;
  }

}
