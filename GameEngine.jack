// Game Engine
// Handles game mechanics

class GameEngine {

  field Settings settings;
  field PXEngine px;
  field GXEngine gx;
  field Array bulletList;
  field int powerSetting;
  field int deBounce; // counts how many frames since the last keystroke
  field Array forceNextRedraw;

  // working variables for methods. Defined here
  // to only make one copy

  constructor GameEngine new(Settings gameSettings,
                             GXEngine myGXEngine,
                             PXEngine myPXEngine) {

    var int i;
    let settings = gameSettings;
    let bulletList = Array.new(settings.getMaxBullets());
    // initialize bulletList
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }

    let gx = myGXEngine;
    let px = myPXEngine;
    let powerSetting = 20;
    let deBounce = 0;
    // forceNextRedraw Array is a series of flags that
    // indicate what needs to be redrawn at the next refresh.
    // 0 - refreshscreen    1 - all players
    // 2 - power indicator  3 - borders
    let forceNextRedraw=Array.new(3);
    let forceNextRedraw[0]=false; let forceNextRedraw[1]=false; let forceNextRedraw[2]=false;
    return this;
  }


  method void takeTurn(Player player) {
    // Allows a player to take a turn.
    // Returns when either dead or next turn
      var int action;
      var int foo, bar;
      var Attributes currentAttributes;

      let currentAttributes = player.getSpriteAttributes();
      let foo = settings.getPlayerStartingPower();
      do player.setPowerRemaining(foo);
      do updateScreen(player);

      while (~player.getIsDead() &
             (player.getPowerRemaining()>0) |
             ~(bulletList[0]=0)  ){
        let action = __getInput__();

        if ( (action=1) & (deBounce<1) ) {
          // Jump action
          let foo = currentAttributes.getRotation();
          let bar = settings.getthrusterAcceleration();
          do px.applyAcceleration(currentAttributes,
                               powerSetting*bar, foo);
          let foo=player.getPowerRemaining();
          do player.setPowerRemaining(foo-powerSetting);
          let forceNextRedraw[2]=true;
        }
        if (action=3) {
          let foo=settings.getRotationSensativity()*-1;
          do px.applyRotation(currentAttributes, foo);
        }
        if (action=4) {
          let foo=settings.getRotationSensativity();
          do px.applyRotation(currentAttributes, foo);
        }
        if (action=5) { // increase power
          let foo=settings.getPowerSensativity();
          do changePower(foo, player.getPowerRemaining());
        }
        if (action=6) { // decrease power
          let foo=settings.getPowerSensativity();
          do changePower(foo*-1, player.getPowerRemaining());
        }
        if ( (action=7) & (deBounce<1) ) { //shoot
          do __shoot__(currentAttributes);
          let foo=player.getPowerRemaining();
          do player.setPowerRemaining(foo-powerSetting);
        }
        // reset the debounce counter.
        if (~(action=0)) {let deBounce=settings.getDebounceSetting();}
        if (deBounce > 0){ let deBounce = deBounce-1; }

        let foo = settings.getTimeStep();
        do px.stepForward(foo);
        do updateScreen(player);
        do Sys.wait(foo);

        // detect collisions
        do checkForCollisions();

        // detect player colision
        let currentAttributes = player.getSpriteAttributes();
        let foo = px.detectCollision(currentAttributes);
        if ( ~(foo=0) ) { do player.kill(); do Output.printInt(foo);}
      }

      return;
    }

    method void __shoot__(Attributes playerAttributes) {
      // shoots a bullet from player. playerAttributes
      // is the attributes object from the shooting player
      var Bullet newBullet;
      var Attributes currentAttributes;
      var int Px,Py,radius, accel, rotation,mass;

      let radius=settings.getBulletRadius();
      let accel=powerSetting;
      let Px = playerAttributes.getPx();
      let Py = playerAttributes.getPy();
      let mass=settings.getBulletMass();

      let newBullet = Bullet.new(Px,Py,0,0,radius, mass);
      do registerBullet(newBullet);
      do gx.registerBullet(newBullet);
      do px.registerBullet(newBullet);
      if ( newBullet.getIsDead() ) {
        do newBullet.dispose();
      } else {
        let currentAttributes = newBullet.getAttributes();
        let rotation = playerAttributes.getRotation();

        do px.applyAcceleration(currentAttributes,accel, rotation);
      }
      let forceNextRedraw[2]=true;
      return;
    }

    method void changePower(int powerDelta, int powerRemaining) {
      let powerSetting = powerSetting + powerDelta;
      if (powerSetting>powerRemaining) { let powerSetting=powerRemaining;}
      if (powerSetting<0) { let powerSetting=0;}
      let forceNextRedraw[2]=true;
      return;
    }


    method int __getInput__() {
      // Polls the keyboard for input and look up
      // the action in the keybinds. Returns an
      // int coresponding with that action.
      var char inputKey;
      var char action;

      let inputKey = Keyboard.keyPressed();
      //do Output.moveCursor(0,0);
      //do Output.printInt(inputKey);
      // don't register inputs if a recent input was made.
      let action = settings.getDesiredAction(inputKey);
      return action;
    }

    method void updateScreen(Player currentPlayer) {
      // if force redraw is true, it'll blank the screen and
      // redraw everything
      var int powerRemaining;
      var int maxPower;

      if (forceNextRedraw[0]) {
        do Screen.clearScreen();
      }
      if (forceNextRedraw[3]|forceNextRedraw[0]) {
        do gx.drawScreenEdges();
      }
      if (forceNextRedraw[2]|forceNextRedraw[0]) {
        let powerRemaining=currentPlayer.getPowerRemaining();
        let maxPower = settings.getPlayerStartingPower();
        do gx.drawPowerIndicator(maxPower,powerRemaining, powerSetting);
      }
      do gx.drawAllObjects(forceNextRedraw[1]|forceNextRedraw[0]);
      let forceNextRedraw[0]=false;
      let forceNextRedraw[1]=false;
      let forceNextRedraw[2]=false;
      let forceNextRedraw[3]=false;
      return;
    }

    method void killBullet(Bullet killBullet) {
      do unregisterBullet(killBullet);
      do gx.unregisterBullet(killBullet);
      do px.unregisterBullet(killBullet);
      do killBullet.dispose();
      let forceNextRedraw[0]=true;
      return;
  }

  method void checkForCollisions() {
    var int i, collisionCode, activationAge;
    var Bullet fooBullet;
    var Attributes currentAttributes;

    // check bullet collisions
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let fooBullet = bulletList[i];
      do fooBullet.agePlusOne();
      let activationAge = settings.getBulletActivationAge();
      if (fooBullet.getAge()>activationAge) { // only check for collisions if the bullet is active
        let currentAttributes = fooBullet.getAttributes();
        let collisionCode = px.detectCollision(currentAttributes);
        if (~(collisionCode=0)) {do killBullet(fooBullet);}
      }
      let i=i+1;
    }
    return;
  }


  method void registerBullet(Bullet newBullet) {
    // adds an gravitySink to the list
    var int i;
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    // if we've reached the max number if bullets, go ahead and kill this one.
    if (i > (settings.getMaxBullets()-1)) {
      do newBullet.setIsDead(true);
    } else {
    let bulletList[i] = newBullet;
    }
    return;
  }

  method void unregisterBullet(Bullet killBullet) {
    var int i;
    let i = 0;
    while(~(bulletList[i]=killBullet) & ~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    if (bulletList[i]=killBullet) { let bulletList[i]=0;}
    return;
  }

}
