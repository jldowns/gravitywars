// Physics Engine
// Handles the movement and collisions of physical objects

class PXEngine {

  field Settings settings;
  field Array bulletList;
  field Array playerSpriteList;
  field AdvancedMath mathEngine;

  field Attributes fooAttributes;

  constructor PXEngine new(Settings gameSettings) {
    var int i;

    let settings=gameSettings;
    let mathEngine=AdvancedMath.new();
    let bulletList = Array.new(settings.getMaxBullets());
    let playerSpriteList = Array.new(settings.getMaxPlayers());

    // initialize the bulletList Array with zeros.
    // All lists terminate with a zero.
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }
    // initialize playerSpriteList
    let i=0;
    while (i<settings.getMaxPlayers()) {
      let playerSpriteList[i] = 0;
      let i=i+1; }

    return this;
  }

  method void registerBullet(Bullet newBullet) {
    // adds an gravitySink to the list
    var int i;
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    let bulletList[i] = newBullet;

    return;
  }

  method void registerPlayerSprite(PlayerSprite newPlayerSprite) {
    // adds a player sprite to the list
    var int i;
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let i=i+1;
    }
    let playerSpriteList[i] = newPlayerSprite;

    return;
  }

  method void applyAcceleration(Attributes att, int accelerationValue, int direction) {
    // Adds an acceleration to the existing acceleration
    var int xComp, yComp;
    var int previousX, previousY;

    do att.backup();
    do att.setNeedsUpdate(true);

    let xComp = (mathEngine.sin100(direction) * accelerationValue) /100;
    let yComp = (mathEngine.cos100(direction) * accelerationValue*-1) /100;

    let previousX = att.getAx();
    let previousY = att.getAy();

    do att.setAcceleration(previousX+xComp, previousY+yComp);

    return;
  }

  method void applyRotation(Attributes att, int rotation) {
    do att.backup();
    do att.setNeedsUpdate(true);
    let rotation = rotation + att.getRotation();
    do att.setRotation(rotation);
    return;
  }

  method void stepForward(int timeDelta) {
    // applies accelerations and velocitys to physical objects
    // over a period of timeDelta
    var int i, x1, y1, x2, y2;
    var PlayerSprite thisPlayerSprite;
    var int friction10;

    // we're going to divide by a modifier here because a 10 millisecond
    // frame delay might not be what we want for a physics time delta.
    let timeDelta = timeDelta / settings.getphysicsTimeStepModifier();
    let friction10=settings.getSpaceFriction() *timeDelta;

    let i = 0;
    while( ~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let thisPlayerSprite = playerSpriteList[i];
      let fooAttributes = thisPlayerSprite.getAttributes();


      // Apply accelerations
      let x1 = fooAttributes.getAx();
      let y1 = fooAttributes.getAy();
      let x2 = fooAttributes.getVx();
      let y2 = fooAttributes.getVy();

      // but only apply them if there is something to apply
      if ( ~(x1=0) | ~(x2=0) | ~(y1=0) | ~(y2=0) ){

        // first, apply space friction
        let x2= ((x2*10*friction10)/100);
        let y2= ((y2*10*friction10)/100);

        do fooAttributes.backup();
        do fooAttributes.setNeedsUpdate(true); // redraw on next frame

        do fooAttributes.setVelocity( (x1*timeDelta) + x2,
                            (y1*timeDelta) + y2 );
        // and reset accelerations now that we've applied them.
        do fooAttributes.setAcceleration(0,0);

        // Apply velocitys
        let x1 = fooAttributes.getPx();
        let y1 = fooAttributes.getPy();
        // x2 and y2 already have velocitys assigned
        do fooAttributes.setCoordinates( (x2*timeDelta) + x1,
                               (y2*timeDelta) + y1 );
      }
      let i=i+1;
    }


    return;
  }



  method void dispose() {
    do Memory.deAlloc(this);
    return; }

}
