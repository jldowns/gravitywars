// Physics Engine
// Handles the movement and collisions of physical objects

class PXEngine {

  field Settings settings;
  field Array bulletList;
  field Array playerSpriteList;
  field Array gravitySinkList;
  field AdvancedMath mathEngine;


  constructor PXEngine new(Settings gameSettings) {
    var int i;

    let settings=gameSettings;
    let mathEngine=AdvancedMath.new();
    let bulletList = Array.new(settings.getMaxBullets());
    let playerSpriteList = Array.new(settings.getMaxPlayers());
    let gravitySinkList = Array.new(settings.getMaxGravitySinks());

    // initialize the bulletList Array with zeros.
    // All lists terminate with a zero.
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }
    // initialize playerSpriteList
    let i=0;
    while (i<settings.getMaxPlayers()) {
      let playerSpriteList[i] = 0;
      let i=i+1; }
    // initialize bulletList
    let i=0;
    while (i<settings.getMaxBullets()) {
      let bulletList[i] = 0;
      let i=i+1; }

    return this;
  }

  method void registerBullet(Bullet newBullet) {
    // adds an gravitySink to the list
    var int i;
    let i = 0;
    while(~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    // if we've reached the max number if bullets, go ahead and kill this one.
    if (i > (settings.getMaxBullets()-1)) {
      do newBullet.setIsDead(true);
    } else {
    let bulletList[i] = newBullet;
    }

    return;
  }

  method void unregisterBullet(Bullet killBullet) {
    var int i;
    let i = 0;
    while(~(bulletList[i]=killBullet) & ~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let i=i+1;
    }
    if (bulletList[i]=killBullet) { let bulletList[i]=0;}
    return;
  }

  method void registerPlayerSprite(PlayerSprite newPlayerSprite) {
    // adds a player sprite to the list
    var int i;
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let i=i+1;
    }
    let playerSpriteList[i] = newPlayerSprite;

    return;
  }

  method void registerGravitySink(GravitySink newGravitySink) {
    // adds an gravitySink to the list
    var int i;
    let i = 0;
    while(~(gravitySinkList[i]=0) & (i<settings.getMaxGravitySinks()) ) {
      let i=i+1;
    }
    let gravitySinkList[i] = newGravitySink;

    return;
  }

  method void applyAcceleration(Attributes att, int accelerationValue, int direction) {
    // Adds an acceleration to the existing acceleration
    var int xComp, yComp;
    var int previousX, previousY;

    do att.backup();
    do att.setNeedsUpdate(true);

    let xComp = (mathEngine.sin100(direction) * accelerationValue) /100;
    let yComp = (mathEngine.cos100(direction) * accelerationValue*-1) /100;

    let previousX = att.getAx();
    let previousY = att.getAy();

    do att.setAcceleration(previousX+xComp, previousY+yComp);

    return;
  }

  method void applyCartesianAcceleration(Attributes att, int xComp, int yComp) {
    // Adds an acceleration to the existing acceleration, using x and y components to
    // skip the sine lookup
    var int previousX, previousY;


    do att.backup();
    do att.setNeedsUpdate(true);

    let previousX = att.getAx();
    let previousY = att.getAy();

    //do Output.printInt(previousX+xComp);
    //do Output.printString(",");
    //do Output.printInt(previousY+yComp);
    //do Output.printString("  ");

    do att.setAcceleration(previousX+xComp, previousY+yComp);
    return;
  }

  method void applyRotation(Attributes att, int rotation) {
    do att.backup();
    do att.setNeedsUpdate(true);
    let rotation = rotation + att.getRotation();
    do att.setRotation(rotation);
    return;
  }

  method void stepForward(int timeDelta) {
    // applies accelerations and velocitys to physical objects
    // over a period of timeDelta
    var int i, x1, y1, x2, y2;
    var PlayerSprite thisPlayerSprite;
    var Bullet thisBullet;
    var int friction10;
    var Attributes currentAttributes;

    // we're going to divide by a modifier here because a 10 millisecond
    // frame delay might not be what we want for a physics time delta.
    let timeDelta = timeDelta / settings.getphysicsTimeStepModifier();
    let friction10=settings.getSpaceFriction() *timeDelta;

    // do the players
    let i = 0;
    while( ~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {
      let thisPlayerSprite = playerSpriteList[i];
      let currentAttributes = thisPlayerSprite.getAttributes();


      // Apply accelerations
      let x1 = currentAttributes.getAx();
      let y1 = currentAttributes.getAy();
      let x2 = currentAttributes.getVx();
      let y2 = currentAttributes.getVy();

      // but only apply them if there is something to apply
      if ( ~(x1=0) | ~(x2=0) | ~(y1=0) | ~(y2=0) ){

        // first, apply space friction
        let x2= ((x2*10*friction10)/100);
        let y2= ((y2*10*friction10)/100);

        do currentAttributes.backup();
        do currentAttributes.setNeedsUpdate(true); // redraw on next frame

        do currentAttributes.setVelocity( (x1*timeDelta) + x2,
                            (y1*timeDelta) + y2 );
        // and reset accelerations now that we've applied them.
        do currentAttributes.setAcceleration(0,0);

        // Apply velocitys
        let x1 = currentAttributes.getPx();
        let y1 = currentAttributes.getPy();
        // x2 and y2 already have velocitys assigned
        do currentAttributes.setCoordinates( (x2*timeDelta) + x1,
                               (y2*timeDelta) + y1 );
      }
      let i=i+1;
    }

    // now do the bullets
    let i = 0;
    while( ~(bulletList[i]=0) & (i<settings.getMaxBullets()) ) {
      let thisBullet = bulletList[i];
      let currentAttributes = thisBullet.getAttributes();

      // apply gravitation field accelerations
      do applyGravitationalField(currentAttributes);

      // Apply accelerations to velocities
      let x1 = currentAttributes.getAx();
      let y1 = currentAttributes.getAy();
      let x2 = currentAttributes.getVx();
      let y2 = currentAttributes.getVy();

      // no space friction for bullets!

      do currentAttributes.backup();
      do currentAttributes.setNeedsUpdate(true); // redraw on next frame

      do currentAttributes.setVelocity( (x1*timeDelta) + x2,
                          (y1*timeDelta) + y2 );
      // and reset accelerations now that we've applied them.
      do currentAttributes.setAcceleration(0,0);

      // Apply velocitys
      let x1 = currentAttributes.getPx();
      let y1 = currentAttributes.getPy();
      // x2 and y2 already have velocitys assigned
      do currentAttributes.setCoordinates( (x2*timeDelta) + x1,
                             (y2*timeDelta) + y1 );
      let i=i+1;
    }


    return;
  }


  method int detectCollision(Attributes att) {
    // Detects whether or not a certain object has hit either
    // a gravity sink, a player sprite, or has fallen off the edge
    // of reality.
    // 0-no collision   1-gravitySink
    // 2-fallenOffEdge  4+ - hit player x-3 (a return value of 5 means you hit player 2)
    var int i,dist;
    var int x1, y1, x2, y2;
    var int r1, r2;
    var int collisionCondition;
    var Attributes currentAttributes;
    var PlayerSprite fooPS;
    var GravitySink fooGS;

    let collisionCondition = 0;
    let x1=att.getPx();
    let y1=att.getPy();
    let r1=att.getRadius();


    // === Check for player collisions ===
    let i = 0;
    while(~(playerSpriteList[i]=0) & (i<settings.getMaxPlayers()) ) {

      let fooPS = playerSpriteList[i];
      let currentAttributes=fooPS.getAttributes();

      if (~(att=currentAttributes)) {
        let x2=currentAttributes.getPx();
        let y2=currentAttributes.getPy();
        let r2 =currentAttributes.getRadius();
        let dist = __getDistance__(x1,y1,x2,y2,r1+r2);
        if (dist < (r1+r2)) {
            let collisionCondition = i+3+1; // this means you hit a player.
        }                                   // since arrays start at 0 and players start at 1, we add one.
      }
      let i=i+1;
    }

    // === Check for Gravity Sink collisions ===
    let i = 0;
    while(~(gravitySinkList[i]=0) & (i<settings.getMaxGravitySinks()) ) {

      let fooGS = gravitySinkList[i];
      let currentAttributes=fooGS.getAttributes();

      if (~(att=currentAttributes)) {
        let x2=currentAttributes.getPx();
        let y2=currentAttributes.getPy();
        let r2 =currentAttributes.getRadius();
        //do Output.moveCursor(0,0);
        //do Output.printInt(x1-x2);
        let dist = __getDistance__(x1,y1,x2,y2,r1+r2);
        if (dist < (r1+r2)) {
            let collisionCondition = 1; // this means you hit a gravity sink.
        }
      }
      let i=i+1;
    }

    // === Check to see if you've exited the universe ===
    let i=settings.getworldResolutionX();
    let x1=x1/i;
    let i=settings.getworldResolutionY();
    let y1=y1/i;

    let x2 = settings.getScreenBoundLeft();
    if ((x1-r1)<x2){ let collisionCondition=2; }

    let x2 = settings.getScreenBoundRight();
    if ((x1+r1)>x2){ let collisionCondition=2; }

    let y2 = settings.getScreenBoundTop();
    if ((y1-r1)<y2){ let collisionCondition=2; }

    let y2 = settings.getScreenBoundBottom();
    if ((y1+r1)>y2){ let collisionCondition=2; }

    return collisionCondition;
  }

  method int __getDistance__(int x1,int y1,int x2,int y2, int envelope) {
    // gets the distance between two cartesian coordinates.
    // To prevent overflows when squaring large numbers, we only
    // calculate the actual distance if the two points are close to the
    // envelope
    var int i;
    let x1 = Math.abs(x1-x2);
    let y1 = Math.abs(y1-y2);

    //do Output.moveCursor(0,0);
    //do Output.printInt(x1);
    //do Output.printString(",");
    //do Output.printInt(y1);
    //do Output.printString("(");
    //do Output.printInt(envelope);
    //
    //do Output.printString(")");
    //do Output.printString("=");

    // to avoid arithmetic overflows
    let x1 = x1 / settings.getworldResolutionX();
    let y1 = y1 / settings.getworldResolutionY();

    // To avoid overflow, we divide by ten until our calculations
    // can be done in 15 bits and then remultiply after the calculation
    let i=1;
    while ( ((x1*x1)>10000) | ((x1*x1)<0) |
            ((y1*y1)>10000) | ((y1*y1)<0) |
            ((x1*x1+y1*y1)>10000) | ((x1*x1+y1*y1)<0) ){
      let x1 = x1/10;
      let y1 = y1/10;
      let i=i+10;
    }

    //if ( ((x1+y1)>envelope) | (x1+y1<0) ) { return envelope+3; }
    //do Output.printString(" x1:");
    //do Output.printInt(x1);
    //do Output.printString(" y1:");
    //do Output.printInt(y1);
    let x1 = Math.sqrt( (x1*x1) + (y1*y1) );
    let x1=x1*i;
    //do Output.printString(":");
    //do Output.printInt(x1);
    //do Output.printString(":");

    return x1;
  }

  method void applyGravitationalField(Attributes att) {
    // Applies acceleration to a specific object based on the
    // proximity to gravitational sinks
    var int i, m1, m2,d,f;
    var int x1,y1,x2,y2;
    var int xComp, yComp;
    var Attributes currentAttributes;
    var GravitySink currentGS;

    let m1 = att.getMass();
    let x1=att.getPx();
    let y1 = att.getPy();

    let i = 0;
    while(~(gravitySinkList[i]=0) & (i<settings.getMaxGravitySinks()) ) {
      let currentGS = gravitySinkList[i];
      let currentAttributes = currentGS.getAttributes();
      let x2=currentAttributes.getPx();
      let y2=currentAttributes.getPy();
      let m2 = currentAttributes.getMass();
      //do Output.printInt(i);
      //do Output.printString(":");
      //do Output.printInt(y1);
      //do Output.printString(",");
      //do Output.printInt(x2);
      //do Output.printString(",");
      //do Output.printInt(y2);
      //do Output.printString(" - ");
      // if the distance between two objects is > 10000 then it's negligable
      let d= __getDistance__(x1,y1,x2,y2,1000);
      //do Output.printInt(m1);
      //do Output.printString("   ");

      // Universal gravitational formula: F=(m1*m2)/d
      let f = (m1*m2)/d;
      // now we're going to skip a few sine calculations by realizing that
      // Fx=F*sin(theta) and sin(theta) = Dx/D, which are two values we know.
      let xComp = f*( (x2-x1)/settings.getworldResolutionX()/d); // x component
      let yComp = f*( (y2-y1)/settings.getworldResolutionY()/d); // y component
      //do Output.printString("    (");
      //do Output.printInt(f);
      //do Output.printString("   ");
      //do Output.printInt(m1);
      //do Output.printString(",");
      //do Output.printInt(m2);
      //do Output.printString(")=");
      // now apply this gravitational pull to our object
      do applyCartesianAcceleration(att, xComp,yComp);
      let x2=att.getAx();
      let y2 = att.getAy();

      let i=i+1;
    }
    return;
  }

  method void dispose() {
    do Memory.deAlloc(bulletList);
    do Memory.deAlloc(playerSpriteList);
    do Memory.deAlloc(mathEngine);
    do Memory.deAlloc(this);
    return; }

}
